const browserify  = require('browserify');
const gulp        = require('gulp');
const notify      = require('gulp-notify');
const plumber     = require('gulp-plumber');
const pug         = require('gulp-pug');
const rimraf      = require('rimraf');
const stylus      = require('gulp-stylus');
const source      = require('vinyl-source-stream');
const sourcemaps  = require('gulp-sourcemaps');
const browserSync = require('browser-sync');
const chokidar    = require('chokidar');

function onError() {
    var args = Array.prototype.slice.call(arguments);
    notify.onError({
        title: "Compile Error",
        message: "<%= error %>"
    }).apply(this, args);
    this.emit('end');
}

gulp.watch = function (glob, opt, task) {
    if (typeof opt === 'string' || typeof task === 'string' || Array.isArray(opt) || Array.isArray(task)) {
        throw new Error('watching ' + glob + ': watch task has to be a function (optionally generated by using gulp.parallel or gulp.series)');
    }
    if (typeof opt === 'function') {
        task = opt;
        opt = {};
    }
    opt = opt || {};
    var fn;
    if (typeof task === 'function' && !opt.noDebounce) {
        let isActive = false;
        fn = () => (isActive || this.parallel(task)(() => isActive = false), isActive = true);
    } else {
        fn = this.parallel(task);
    }
    if (opt.wait) {
        fn = _.debounce(fn, opt.wait);
    }
    if (opt.ignoreInitial == null) {
        opt.ignoreInitial = true;
    }
    var watcher = chokidar.watch(glob, opt);
    if (fn) {
        watcher.on('change', fn).on('unlink', fn).on('add', fn);
    }
    return watcher;
};

gulp.task('clean', (cb) => {
  return rimraf('./dist', cb);
});

gulp.task('template', () => {
  return gulp.src(['./src/*.pug'])
    .pipe(plumber({
      errorHandler: notify.onError("Error: <%= error.message %>")
    }))
    .pipe(pug({
      pretty: true
    }))
    .pipe(gulp.dest('./dist/'));
});

gulp.task('style', () => {
  return gulp.src(['./src/styles/**/*.styl'])
    .pipe(plumber({
      errorHandler: notify.onError("Error: <%= error.message %>")
    }))
    .pipe(sourcemaps.init())
    .pipe(stylus({
      compress: true
    }))
    .pipe(sourcemaps.write())
    .pipe(gulp.dest('./dist/assets/styles/'));
});

gulp.task('compile', (cb) => {
  return browserify({ entries: './src/scripts/index.ts' })
    .plugin('tsify', {
        debug: true
    })
    .bundle()
    .on('error', onError)
    .pipe(source('index.js'))
    .pipe(gulp.dest(`./dist/assets/scripts/`))
    .on('end', cb);
});

gulp.task('copy', (cb) => {
    return gulp.src(['./src/img/**/*'])
        .pipe(gulp.dest('./dist/assets/img/'));
});

gulp.task('watch', () => {
    const server = browserSync.create();
    server.init({
        server: {baseDir: 'dist'},
        reloadDelay: 1000
    }, () => {
        gulp.watch(['./dist/**/*.html', './dist/**/*.js'], {noDebounce: true}, () => server.reload());
        gulp.watch('./dist/**/*.css', {noDebounce: true}, () => server.reload('*.css'));
        gulp.watch('./src/*.pug', gulp.series('template'));
        gulp.watch('./src/styles/**/*.styl', gulp.series('style'));
        gulp.watch('./src/scripts/**/*.ts', gulp.series('compile'));
        gulp.watch('./src/img/**/*', gulp.series('copy'));
    });
    return server;
});

gulp.task(
    'default',
    gulp.series(
        'clean',
        gulp.parallel('template', 'style', 'compile', 'copy'),
        'watch'
    )
);